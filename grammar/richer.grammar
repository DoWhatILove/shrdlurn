# contextful top level functions
(def @rootFn context:edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.root)

(def @iff edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.iff)

# actions
(def @add edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.add)
(def @remove edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.remove)

# action combiners
(def @serial edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.seq)
(def @repeat edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.repeat)

# filters and their combiners
(def @filter edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.filter)
(def @topColor edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.top)
(def @contains edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.has)

(def @not edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.not)
(def @combine edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.logic)

(def @get edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.get)

# This grammar should have Rule.defaultIsFloating false
# TO TEST
# (context (graph NaiveKnowledgeGraph ((string [[1,2,3,4],[4,3,1],[2,2,1],[2,2,3],[3],[]]) (name b) (name c))))
#  (set JavaExecutor.printStackTrace true)
####### Start of the actual grammar

(rule $ROOT ($ActionSeq) (lambda a (call @rootFn (var a)) )) # process for better

(rule $Action ($ActionSeq if $CondSeq) (lambda a (lambda c (call @iff (var c) (var a)))))
(rule $Action (do $ActionSeq if $CondSeq) (lambda a (lambda c (call @iff (var c) (var a)))))
# (rule $Action ($ActionSeq $CondSeq) (lambda a (lambda c (call @iff (var c) (var a)))) (floating 1))

(rule $Action ([ $ActionSeq ]) (IdentityFn))
(rule $Action ([ $Action ]) (IdentityFn))

# combo actions
(rule $ActionSeq ($ActionSeq then $Action) (lambda a1 (lambda a2 (call @serial (var a1) (var a2)))))
# (rule $ActionSeq ($ActionSeq $Action) (lambda a1 (lambda a2 (call @serial (var a1) (var a2)))) (floating 1))

(rule $ActionSeq ($Action) (IdentityFn))
(rule $Action (repeat $Action $NUM times) (lambda a (lambda n (call @repeat (var n) (var a)))))
# (rule $Action ($Action $NUM) (lambda a (lambda n (call @repeat (var n) (var a)))) (floating 1))

# combo conditions
(for @op (or and)
(rule $CondSeq ($CondSeq @op $Cond) (lambda c1 (lambda c2
					(call @combine (string @op) (var c1) (var c2)))))
# (rule $CondSeq ($CondSeq $Cond) (lambda c1 (lambda c2
#					(call @combine (string @op) (var c1) (var c2)))) (floating 1))
)

(rule $Cond ([ $CondSeq ]) (IdentityFn))
(rule $Cond ([ $Cond ]) (IdentityFn))

(rule $Cond (not $Cond) (lambda c (call @not (var c))))
(rule $CondSeq ($Cond) (IdentityFn))

# could remove some of these
(for @rel (> >= = < <= %=)
(rule $Cond ($Getter @rel $NUM) (lambda g (lambda n
(call @filter (var g) (string @rel) (var n)))))
)

(rule $Action (remove) (ConstantFn (call @remove)))
(rule $Action (add $Color) (lambda t (call @add (var t))))

(for @property (col row height)
     (rule $Getter (@property) (ConstantFn (call @get (string @property))))
)

# basic conditions
(rule $Cond (has $Color) (lambda t
			      (call @contains (var t))) (anchored 1))
(rule $Cond (top $Color) (lambda t
			      (call @topColor (var t))) (anchored 1))


(rule $NUM ($TOKEN) (NumberFn))
# cyan brown red orange yellow
(rule $Color (cyan) (ConstantFn (number 0 COLOR)) (anchored 1))
(rule $Color (brown) (ConstantFn (number 1 COLOR)) (anchored 1))
(rule $Color (red) (ConstantFn (number 2 COLOR)) (anchored 1))
(rule $Color (orange) (ConstantFn (number 3 COLOR)) (anchored 1))
(rule $Color (yellow) (ConstantFn (number 4 COLOR)) (anchored 1))

