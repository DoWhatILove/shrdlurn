# contextful top level functions
(def @rootFn context:edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.rootFn)
(def @condition edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.condition)

# actions
(def @add edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.add)
(def @remove edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.remove)

# action combiners
(def @serial edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.serial)
(def @repeat edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.repeat)

# filters and their combiners
(def @filter edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.filter)
(def @contains edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.contains)
(def @topColor edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.topColor)

(def @not edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.not)
(def @combine edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.combine)

# TO TEST
# (context (graph NaiveKnowledgeGraph ((string [[1,2,3,4],[4,3,1],[2,2,1],[2,2,3],[3],[]]) (name b) (name c))))
#  (set JavaExecutor.printStackTrace true)
####### Start of the actual grammar

(rule $ROOT ($Action) (lambda a (call @rootFn (var a)) )) # process for better
(rule $Action ($Action if $Cond) (lambda a (lambda c (call @condition (var a) (var c)))))

# combo actions
(rule $Action ( { $Action } ) (IdentityFn))
(rule $Action ($Action then $Action) (lambda a1 (lambda a2 (call @serial (var a1) (var a2)))))
(rule $Action (repeat $Action $NUM times ) (lambda a (lambda n (call @repeat (var n) (var a)))))

# basic actions
(rule $Action (remove) (ConstantFn (call @remove)))
(rule $Action (add $Type) (lambda t (call @add (var t))))

# combo conditions
(for @op (or and diff)
(rule $Cond ($Cond @op $Cond) (lambda s1 (lambda s2
					(call @combine (string @op) (var s1) (var s2)))))
)

(rule $Cond (not $Cond) (lambda c (call @not (var c))))

(rule $Cond ( { $Cond } ) (IdentityFn))

# basic conditions

(rule $Cond (top $Type) (lambda t
			      (call @topColor (var t))))
(rule $Cond (contains $Type) (lambda t
			      (call @contains (var t))))
     
(for @numprop (col row height)
     (rule $Cond (@numprop >  $NUM) (lambda n 
				    (call @filter (string @numprop) (string >) (var n))))
     (rule $Cond (@numprop >= $NUM)  (lambda n
				    (call @filter (string @numprop) (string >=) (var n))))
     (rule $Cond (@numprop =  $NUM)  (lambda n
				    (call @filter (string @numprop) (string =) (var n))))
     (rule $Cond (@numprop <  $NUM)  (lambda n
				    (call @filter (string @numprop) (string <) (var n))))
     (rule $Cond (@numprop <= $NUM)  (lambda n
				    (call @filter (string @numprop) (string <=) (var n))))
     )

(rule $NUM ($TOKEN) (NumberFn))
# cyan brown red orange yellow
(rule $Type (cyan) (ConstantFn (number 0 COLOR)))
(rule $Type (brown) (ConstantFn (number 1 COLOR)))
(rule $Type (red) (ConstantFn (number 2 COLOR)))
(rule $Type (orange) (ConstantFn (number 3 COLOR)))
(rule $Type (yellow) (ConstantFn (number 4 COLOR)))

# repeat add red 2 times then add cyan if height > 2
# add red if col < 3 and row < 3
# add red if col > 2 and col < 5 or row > 2 and row < 5
# repeat add red if height < 3 10 times
# repeat add red 5 times if height > 0
# add red then add cyan then add yellow if row > 3 and col > 3 and height > 0

# add red then add cyan then repeat add yellow 3 times if height < 1 and row < 5 and col < 5 or col > 8 then add brown
# add red then add yellow if col > 1 then add cyan if col > 2 then add brown if col > 3 then add orange if col > 4
# { remove if col > 5 } then { remove if col > 6 } then { remove if col > 7 }
# remove if row > 5 then remove if row > 6 then remove if row > 7
# remove if row < 4 then remove if row < 3 then remove if row < 2
# { remove if col  < 4 } then { remove if col < 3 } then { remove if col < 2 }
# repeat add red if height < 3 10 times