# actions, all contexful
(def @removeAll context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.removeAll)
(def @removeTop context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.removeTop)
(def @stackOnTop context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.stackOnTop)
(def @doubleTop context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.doubleTop)

# uncontextful binary set ops
(def @setUnion edu.stanford.nlp.sempre.cubeworld.StacksWorld.setUnion)
(def @setIntersection edu.stanford.nlp.sempre.cubeworld.StacksWorld.setIntersection)
(def @setDifference edu.stanford.nlp.sempre.cubeworld.StacksWorld.setDifference)

# uncontextful unary set ops
(def @leftMost1 edu.stanford.nlp.sempre.cubeworld.StacksWorld.leftMost1)
(def @rightMost1 edu.stanford.nlp.sempre.cubeworld.StacksWorld.rightMost1)
(def @leftMost edu.stanford.nlp.sempre.cubeworld.StacksWorld.leftMost)
(def @rightMost edu.stanford.nlp.sempre.cubeworld.StacksWorld.rightMost)
(def @complement edu.stanford.nlp.sempre.cubeworld.StacksWorld.complement)

# contextful first level primitives
(def @getColor context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.getColor)
(def @getTopColor context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.getTopColor)
(def @getAll context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.getAll)
(def @getGEQ context:edu.stanford.nlp.sempre.cubeworld.StacksWorld.getGEQ)

# final ops
(def @wallToString edu.stanford.nlp.sempre.cubeworld.StacksWorld.wallToString)
####### Start of the actual grammar

(rule $ROOT ($Action) (lambda a (call @wallToString (var a)) )) # excecute some action
# (rule $ROOT ($Action $Action) (lambda a (call @wallToString (var a)) ))
(rule $Action ( $Set ) (lambda s (call @removeTop (var s) )))
(rule $Action ( $Set $Color )
      (lambda s (lambda c (call @stackOnTop (var s) (var c)))))

(for @x (0 1 2 3) 
     (rule $Color (tok) (ConstantFn (number @x COLOR)))
)
# (rule $Set ($Count) (lambda h (call @getGEQ (var h))))
(for @x (1) 
     (rule $Count (tok) (ConstantFn (number @x COUNT)))
)

(rule $Set (tok) (ConstantFn (call @getAll)))

(rule $Set (tok $Color) (lambda c (call @getColor  (var c) )))
(rule $Set (tok $Color) (lambda c (call @getTopColor  (var c) )))
(rule $Set ($Set $Count) (lambda s (lambda n (call @leftMost (var s) (var n) )))) 
(rule $Set ($Set $Count) (lambda s (lambda n (call @rightMost (var s)  (var n)))))
#(rule $Set (tok $Set) (lambda s (call @complement (var s) )))
#(rule $Set (tok $Set) (lambda s (call @leftMost1 (var s) )))
#(rule $Set (tok $Set) (lambda s (call @rightMost1 (var s) )))

#(rule $Set ($Set $Set) (lambda s1 (lambda s2
#(call @setIntersection (var s1) (var s2)))))
#(rule $Set ($Set $Set) (lambda s1 (lambda s2
#(call @setUnion (var s1) (var s2)))))

#(rule $Set ($Set $Set) (lambda s1 (lambda s2
#(call @setDifference (var s1) (var s2)))))

(when usenumbers 
(rule $Count ($TOKEN) (NumberFn) (anchored 1))
)