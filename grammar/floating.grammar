#

# actions, all contexful
(def @changeSetColor context:edu.stanford.nlp.sempre.cubeworld.CubeWorld.changeSetColor)
(def @removeSet context:edu.stanford.nlp.sempre.cubeworld.CubeWorld.removeSet)
(def @keepSet context:edu.stanford.nlp.sempre.cubeworld.CubeWorld.keepSet)
(def @stackOnTop context:edu.stanford.nlp.sempre.cubeworld.CubeWorld.stackOnTop)

# uncontextful binary set ops
(def @setUnion edu.stanford.nlp.sempre.cubeworld.CubeWorld.setUnion)
(def @setIntersection edu.stanford.nlp.sempre.cubeworld.CubeWorld.setIntersection)
(def @setDifference edu.stanford.nlp.sempre.cubeworld.CubeWorld.setDifference)

# uncontextful unary set ops
(def @topOfSet edu.stanford.nlp.sempre.cubeworld.CubeWorld.topOfSet)
(def @bottomOfSet edu.stanford.nlp.sempre.cubeworld.CubeWorld.bottomOfSet)
(def @complementOfSet edu.stanford.nlp.sempre.cubeworld.CubeWorld.complementOfSet)

# contextful first level primitives
(def @getColor context:edu.stanford.nlp.sempre.cubeworld.CubeWorld.getColor)
(def @getAll context:edu.stanford.nlp.sempre.cubeworld.CubeWorld.getAll)

(def @wallToString edu.stanford.nlp.sempre.cubeworld.CubeWorld.wallToString)

(rule $ROOT ($Action) (lambda a (call @wallToString (var a)) )) # excecute some action
# (rule $ROOT ($Action) (IdentityFn)) # excecute some action
(rule $Action ( $Set ) (lambda s (call @removeSet (var s) )))
(rule $Action ( $Set ) (lambda s (call @keepSet (var s) )))
(rule $Action ( $Set $Color )
      (lambda s (lambda c (call @changeSetColor (var s) (var c)))))
(rule $Action ( $Set $Color )
      (lambda s (lambda c (call @stackOnTop (var s) (var c)))))

(rule $Set (tok) (ConstantFn (call @getAll)))
(rule $Set ($Color) (lambda c (call @getColor (var c) )))
(for @x (0 1 2 3) 
     (rule $Color (tok) (ConstantFn (number @x COLOR)))
)

(rule $Set (tok $Set) (lambda r (call @topOfSet (var r) )))
(rule $Set (tok $Set) (lambda r (call @bottomOfSet (var r) )))
(rule $Set (tok $Set) (lambda r (call @complementOfSet (var r) )))

(rule $Set ($Set $Set) (lambda s1 (lambda s2
(call @setIntersection (var s1) (var s2)))))

(rule $Set ($Set $Set) (lambda s1 (lambda s2
(call @setUnion (var s1) (var s2)))))
(rule $Set ($Set $Set) (lambda s1 (lambda s2
(call @setDifference (var s1) (var s2)))))

(when false (
(rule $Action ( change $Set $Color )
      (lambda s (lambda c (call @changeSetColor (var s) (var c)))))
(rule $Action ( stack $Set $Color )
      (lambda s (lambda c (call @stackOnTop (var s) (var c)))))
      
(rule $Set ( or $Set $Set) (lambda s1 (lambda s2
(call @setUnion (var s1) (var s2)))))
(rule $Set ( $Set or $Set) (lambda s1 (lambda s2
(call @setUnion (var s1) (var s2)))))

(rule $Set ( and $Set $Set) (lambda s1 (lambda s2
(call @setIntersection (var s1) (var s2)))))
(rule $Set ( $Set and $Set) (lambda s1 (lambda s2
(call @setIntersection (var s1) (var s2)))))

(rule $Set ( $Set but not $Set) (lambda s1 (lambda s2
(call @setDifference (var s1) (var s2)))))

(rule $Set (row $Number) (lambda c (call @getRowBottom (var c) )))
(rule $Set (top $Number) (lambda c (call @getRowTop (var c) )))

(rule $Number ($PHRASE) (NumberFn) (anchored 1))

(when false (
	     (rule $Color (cyan) (ConstantFn (number 0 COLOR)))
	     (rule $Color (brown) (ConstantFn (number 1 COLOR)))
	     (rule $Color (red) (ConstantFn (number 2 COLOR)))
	     (rule $Color (orange) (ConstantFn (number 3 COLOR)))
	     (rule $Color (yellow) (ConstantFn (number 4 COLOR)))
	     ))

(for @x (0 1 2) 
     (rule $Color ($TOKEN) (ConstantFn (number @x COLOR)))
)
))