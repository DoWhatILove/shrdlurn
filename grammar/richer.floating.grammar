# contextful top level functions
(def @rootFn context:edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.rootFn)
(def @condition edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.condition)

# actions
(def @add edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.add)
(def @remove edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.remove)

# action combiners
(def @serial edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.serial)
(def @repeat edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.repeat)

# filters and their combiners
(def @filter edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.filter)
(def @contains edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.contains)
(def @topColor edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.topColor)

(def @not edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.not)
(def @combine edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.combine)

(def @get edu.stanford.nlp.sempre.cubeworld.RicherStacksWorld.get)

# This grammar should have Rule.defaultIsFloating true
# TO TEST
# (context (graph NaiveKnowledgeGraph ((string [[1,2,3,4],[4,3,1],[2,2,1],[2,2,3],[3],[]]) (name b) (name c))))
#  (set JavaExecutor.printStackTrace true)
####### Start of the actual grammar

(rule $ROOT ($ActionSeq) (lambda a (call @rootFn (var a)) )) # process for better
(rule $Action ($ActionSeq $CondSeq) (lambda a (lambda c (call @condition (var a) (var c)))))

# combo actions
(rule $ActionSeq ($ActionSeq $Action2) (lambda a1 (lambda a2 (call @serial (var a1) (var a2)))))
(rule $ActionSeq ($Action2) (IdentityFn))

# Action2 exists to prevent consecutive repeats. Maybe do with a flag
(rule $Action2 ($Action $NUM) (lambda a (lambda n (call @repeat (var n) (var a)))))
(rule $Action2 ($Action) (IdentityFn))

# basic actions
(rule $Action (nothing) (ConstantFn (call @remove)))
(rule $Action ($Color) (lambda t (call @add (var t))))

# combo conditions
(for @op (or and diff)
(rule $CondSeq ($CondSeq $Cond2) (lambda c1 (lambda c2
					(call @combine (string @op) (var c1) (var c2)))))
)
(rule $CondSeq ($Cond2) (IdentityFn))
(rule $Cond2 ($Cond) (lambda c (call @not (var c))))
(rule $Cond2 ($Cond) (IdentityFn))

# basic conditions
(rule $Cond ($Color) (lambda t
			      (call @topColor (var t))))
(rule $Cond ($Color) (lambda t
			      (call @contains (var t))))
     
(for @property (col row height)
     (rule $Getter (@property) (ConstantFn (call @get (string @property))))
)

# could remove some of these
(for @rel (> >= = < <= %=)
(rule $Cond ($Getter $NUM) (lambda g (lambda n
(call @filter (var g) (string @rel) (var n)))))
)

(rule $NUM ($TOKEN) (NumberFn) (anchored 1))
# cyan brown red orange yellow
(rule $Color (cyan) (ConstantFn (number 0 COLOR)) (anchored 1))
(rule $Color (brown) (ConstantFn (number 1 COLOR)) (anchored 1))
(rule $Color (red) (ConstantFn (number 2 COLOR)) (anchored 1))
(rule $Color (orange) (ConstantFn (number 3 COLOR)) (anchored 1))
(rule $Color (yellow) (ConstantFn (number 4 COLOR)) (anchored 1))